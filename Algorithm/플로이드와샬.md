## 1. 플로이드와샬(Floyd-warshell) 알고리즘이란?

- 그래프에서 모든 정점 사이의 최단거리를 구하는 알고리즘을 말합니다.
- 음수 가중치가 있으면 처리하기 힘든 다익스트라 알고리즘과는 다르게 플로이드 와샬 알고리즘은 음수 가중치를 처리할 수 있다.
<br><br>

## 2. 플로이드와샬 처리 과정

### 2.0 테스트 할 수 있는 경로 그래프 하나를 예시로 들기

다음과 같은 경로 그래프가 있다고 합시다.

```java
int[][] road = {{1, 2, 4}, {1, 4, 8}, {2, 4, 2}, {3, 2, 1}, {3, 4, 5}, {4, 3, 6}}
```

`{1, 2, 4}`의 의미는 node 1에서 node 2로 이동하는 경로가 4가지 있다는 것을 의미합니다.

### 2.1 모든 경로에 대한 테이블을 하나 만들고 INF 값으로 초기화 하기

이때 주의해야 하는 것은 정점 두 개가 같은 지점은 0으로 초기화 합니다. 

왜냐하면 node 1에서 node 1로 가는 방법은 0이기 때문입니다.

| 0 | INF | INF | INF |
| --- | --- | --- | --- |
| INF | 0 | INF | INF |
| INF | INF | 0 | INF |
| INF | INF | INF | 0 |

```java
int[][] map = new map[node의 개수 + 1][node의 개수 + 1];

for(int i = 1; i <= node의 개수; i++) {
    for(int j = 1; j <= node의 개수; j++) {
	if(i == j) map[i][j] = 0;
	map[i][j] = INF;
    }
}

// i가 0과 j가 0인 경우도 있지만, 표에서는 그리지 않겠습니다.
```

여기서 INF는 임의로 지정해준 값입니다. `Integer.MAX_VALUE`를 쓰는 경우도 많이 봤지만, 문제에서 지정된 최대 값의 범위가 있는 경우에는 INF로 값을 지정해서 사용해도 무방합니다.

```java
// EX)
final int INF = 5000;
```

### 2.2 경로 데이터인 road를 map에 반영하기

| 0 | 4 | INF | 8 |
| --- | --- | --- | --- |
| INF | 0 | INF | 2 |
| INF | 1 | 0 | 5 |
| INF | INF | 6 | 0 |

```java
for(int i = 0; i < road.length; i++) {
    map[road[i][0]][road[i][1]] = road[i][2];
}
```

이 예제의 경우는 방향이 정해져 있기 때문에 반대 방향으로 가는 경우는 생각해주지 않아도 된다. 만약 양방향성을 가지고 있다고 한다면 다음과 같은 코드를 추가해주면 된다.

```java
map[road[i][1]][road[i][0]] = road[i][2]; // 반대 방향도 적용
```

### 2.3 node 1부터 node n까지 순차적으로 거쳐지나가는 정점을 모두 고려

시작 정점에서 목표 정점까지 바로 가는 거리보다 또 다른 정점을 거쳐 지나가는 거리가 짧으면 업데이트를 해준다.

예시로 하나를 들어보면 다음과 같다.

node 1에서 node 4로 가는 방법은 지금 8이다. 만약 node 1에서 node 2로 간 후  node 2에서 node 4로 가는 경우는 4 + 2로 6이다. 

즉, 거쳐가는 node를 2로 했을 때, 값이 8에서 6으로 업데이트 되는 것이다.

<변경전>

| 0 | 4 | INF | 8 |
| --- | --- | --- | --- |
| INF | 0 | INF | 2 |
| INF | 1 | 0 | 5 |
| INF | INF | 6 | 0 |

<변경후>

| 0 | 4 | INF | 6 |
| --- | --- | --- | --- |
| INF | 0 | INF | 2 |
| INF | 1 | 0 | 5 |
| INF | INF | 6 | 0 |

위와 같은 방법을 모두 거치고 나면 표가 아래와 같이 업데이트된다.

| 0 | 4 | 12 | 6 |
| --- | --- | --- | --- |
| INF | 0 | 8 | 2 |
| INF | 1 | 0 | 3 |
| INF | 7 | 6 | 0 |

```java
for(int j = 1; j <= node의 개수; j++) {
    for(int i = 1; i <= node의 개수; i++) {
	for(int k = 1; k <= node의 개수; k++) {
	    if(map[i][k] > map[i][j] + map[j][k]) {
		map[i][k] = map[i][j] + map[j][k];
	    }
	}
    }
}
```

위 코드에서 거쳐가는 node는 j 입니다. node i에서 node k로 바로 가는 길과 node i에서 node j를 거쳐 node k로 가는 경로를 비교합니다. 만약 거쳐서 가는 경로가 더 작다면 map에서 새로운 값을 업데이트합니다.
